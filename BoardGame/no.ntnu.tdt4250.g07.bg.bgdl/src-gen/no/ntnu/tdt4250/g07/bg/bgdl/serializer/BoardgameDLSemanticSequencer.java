/*
 * generated by Xtext 2.35.0
 */
package no.ntnu.tdt4250.g07.bg.bgdl.serializer;

import com.google.inject.Inject;
import java.util.Set;
import no.ntnu.tdt4250.g07.bg.bgdl.services.BoardgameDLGrammarAccess;
import no.ntnu.tdt4250.group07.bg.BgPackage;
import no.ntnu.tdt4250.group07.bg.Board;
import no.ntnu.tdt4250.group07.bg.BoardState;
import no.ntnu.tdt4250.group07.bg.Brick;
import no.ntnu.tdt4250.group07.bg.BrickChange;
import no.ntnu.tdt4250.group07.bg.BrickState;
import no.ntnu.tdt4250.group07.bg.BrickType;
import no.ntnu.tdt4250.group07.bg.Cell;
import no.ntnu.tdt4250.group07.bg.CellChange;
import no.ntnu.tdt4250.group07.bg.CellState;
import no.ntnu.tdt4250.group07.bg.CellType;
import no.ntnu.tdt4250.group07.bg.Condition;
import no.ntnu.tdt4250.group07.bg.EffectOnCell;
import no.ntnu.tdt4250.group07.bg.Line;
import no.ntnu.tdt4250.group07.bg.LineElement;
import no.ntnu.tdt4250.group07.bg.Outcome;
import no.ntnu.tdt4250.group07.bg.PlayerBrickSet;
import no.ntnu.tdt4250.group07.bg.RelativePosition;
import no.ntnu.tdt4250.group07.bg.Rules;
import no.ntnu.tdt4250.group07.bg.ValidMove;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;

@SuppressWarnings("all")
public class BoardgameDLSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private BoardgameDLGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == BgPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case BgPackage.BOARD:
				sequence_Board(context, (Board) semanticObject); 
				return; 
			case BgPackage.BOARD_STATE:
				sequence_BoardState(context, (BoardState) semanticObject); 
				return; 
			case BgPackage.BRICK:
				sequence_Brick(context, (Brick) semanticObject); 
				return; 
			case BgPackage.BRICK_CHANGE:
				sequence_BrickChange(context, (BrickChange) semanticObject); 
				return; 
			case BgPackage.BRICK_STATE:
				sequence_BrickState(context, (BrickState) semanticObject); 
				return; 
			case BgPackage.BRICK_TYPE:
				sequence_BrickType(context, (BrickType) semanticObject); 
				return; 
			case BgPackage.CELL:
				sequence_Cell(context, (Cell) semanticObject); 
				return; 
			case BgPackage.CELL_CHANGE:
				sequence_CellChange(context, (CellChange) semanticObject); 
				return; 
			case BgPackage.CELL_STATE:
				sequence_CellState(context, (CellState) semanticObject); 
				return; 
			case BgPackage.CELL_TYPE:
				sequence_CellType(context, (CellType) semanticObject); 
				return; 
			case BgPackage.CONDITION:
				sequence_Condition(context, (Condition) semanticObject); 
				return; 
			case BgPackage.EFFECT_ON_CELL:
				sequence_EffectOnCell(context, (EffectOnCell) semanticObject); 
				return; 
			case BgPackage.LINE:
				sequence_Line(context, (Line) semanticObject); 
				return; 
			case BgPackage.LINE_ELEMENT:
				sequence_LineElement(context, (LineElement) semanticObject); 
				return; 
			case BgPackage.OUTCOME:
				sequence_Outcome(context, (Outcome) semanticObject); 
				return; 
			case BgPackage.PLAYER_BRICK_SET:
				sequence_PlayerBrickSet(context, (PlayerBrickSet) semanticObject); 
				return; 
			case BgPackage.RELATIVE_POSITION:
				sequence_RelativePosition(context, (RelativePosition) semanticObject); 
				return; 
			case BgPackage.RULES:
				sequence_Rules(context, (Rules) semanticObject); 
				return; 
			case BgPackage.VALID_MOVE:
				sequence_ValidMove(context, (ValidMove) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * <pre>
	 * Contexts:
	 *     BoardState returns BoardState
	 *
	 * Constraint:
	 *     (Toggleable?='Toggleable' Name=EString)
	 * </pre>
	 */
	protected void sequence_BoardState(ISerializationContext context, BoardState semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, BgPackage.Literals.BOARD_STATE__TOGGLEABLE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, BgPackage.Literals.BOARD_STATE__TOGGLEABLE));
			if (transientValues.isValueTransient(semanticObject, BgPackage.Literals.BOARD_STATE__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, BgPackage.Literals.BOARD_STATE__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getBoardStateAccess().getToggleableToggleableKeyword_0_0(), semanticObject.isToggleable());
		feeder.accept(grammarAccess.getBoardStateAccess().getNameEStringParserRuleCall_4_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Board returns Board
	 *
	 * Constraint:
	 *     (
	 *         Name=EString 
	 *         Width=EInt 
	 *         Height=EInt 
	 *         cell+=[Cell|EString] 
	 *         cell+=[Cell|EString]* 
	 *         (boardstate+=[BoardState|EString] boardstate+=[BoardState|EString]*)? 
	 *         playerbrickset+=PlayerBrickSet 
	 *         playerbrickset+=PlayerBrickSet* 
	 *         validmove+=ValidMove 
	 *         validmove+=ValidMove*
	 *     )
	 * </pre>
	 */
	protected void sequence_Board(ISerializationContext context, Board semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     BrickChange returns BrickChange
	 *
	 * Constraint:
	 *     (
	 *         Name=EString 
	 *         positionchange=[RelativePosition|EString]? 
	 *         movingBrick=[BrickType|EString]? 
	 *         changeFrom=[BrickType|EString]? 
	 *         changeTo=[BrickType|EString]? 
	 *         (condition+=[Condition|EString] condition+=[Condition|EString]*)?
	 *     )
	 * </pre>
	 */
	protected void sequence_BrickChange(ISerializationContext context, BrickChange semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     BrickState returns BrickState
	 *
	 * Constraint:
	 *     Name=EString
	 * </pre>
	 */
	protected void sequence_BrickState(ISerializationContext context, BrickState semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, BgPackage.Literals.BRICK_STATE__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, BgPackage.Literals.BRICK_STATE__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getBrickStateAccess().getNameEStringParserRuleCall_3_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     BrickType returns BrickType
	 *
	 * Constraint:
	 *     (
	 *         Name=EString 
	 *         brickstate+=[BrickState|EString] 
	 *         brickstate+=[BrickState|EString]* 
	 *         (effectoncell+=[EffectOnCell|EString] effectoncell+=[EffectOnCell|EString]*)?
	 *     )
	 * </pre>
	 */
	protected void sequence_BrickType(ISerializationContext context, BrickType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Brick returns Brick
	 *
	 * Constraint:
	 *     (bricktype=[BrickType|EString] startCell=[Cell|EString]?)
	 * </pre>
	 */
	protected void sequence_Brick(ISerializationContext context, Brick semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     CellChange returns CellChange
	 *
	 * Constraint:
	 *     (Name=EString (condition+=[Condition|EString] condition+=[Condition|EString]*)? changeFrom=[CellType|EString] changeTo=[CellType|EString])
	 * </pre>
	 */
	protected void sequence_CellChange(ISerializationContext context, CellChange semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     CellState returns CellState
	 *
	 * Constraint:
	 *     Name=EString
	 * </pre>
	 */
	protected void sequence_CellState(ISerializationContext context, CellState semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, BgPackage.Literals.CELL_STATE__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, BgPackage.Literals.CELL_STATE__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getCellStateAccess().getNameEStringParserRuleCall_3_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     CellType returns CellType
	 *
	 * Constraint:
	 *     (Name=EString cellstate+=[CellState|EString] cellstate+=[CellState|EString]*)
	 * </pre>
	 */
	protected void sequence_CellType(ISerializationContext context, CellType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Cell returns Cell
	 *
	 * Constraint:
	 *     (Xposition=EInt Yposition=EInt celltype=[CellType|EString])
	 * </pre>
	 */
	protected void sequence_Cell(ISerializationContext context, Cell semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, BgPackage.Literals.CELL__XPOSITION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, BgPackage.Literals.CELL__XPOSITION));
			if (transientValues.isValueTransient(semanticObject, BgPackage.Literals.CELL__YPOSITION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, BgPackage.Literals.CELL__YPOSITION));
			if (transientValues.isValueTransient(semanticObject, BgPackage.Literals.CELL__CELLTYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, BgPackage.Literals.CELL__CELLTYPE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getCellAccess().getXpositionEIntParserRuleCall_3_0(), semanticObject.getXposition());
		feeder.accept(grammarAccess.getCellAccess().getYpositionEIntParserRuleCall_5_0(), semanticObject.getYposition());
		feeder.accept(grammarAccess.getCellAccess().getCelltypeCellTypeEStringParserRuleCall_7_0_1(), semanticObject.eGet(BgPackage.Literals.CELL__CELLTYPE, false));
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Condition returns Condition
	 *
	 * Constraint:
	 *     (
	 *         mandatory?='mandatory' 
	 *         prohibited?='prohibited' 
	 *         Name=EString 
	 *         (boardstate+=[BoardState|EString] boardstate+=[BoardState|EString]*)? 
	 *         relativeposition=[RelativePosition|EString]? 
	 *         bricktype=[BrickType|EString]? 
	 *         brickstate=[BrickState|EString]? 
	 *         celltype=[CellType|EString]? 
	 *         cellstate=[CellState|EString]? 
	 *         (line+=[Line|EString] line+=[Line|EString]*)?
	 *     )
	 * </pre>
	 */
	protected void sequence_Condition(ISerializationContext context, Condition semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     EffectOnCell returns EffectOnCell
	 *
	 * Constraint:
	 *     (Name=EString relativeposition+=[RelativePosition|EString] relativeposition+=[RelativePosition|EString]* cellstate=[CellState|EString])
	 * </pre>
	 */
	protected void sequence_EffectOnCell(ISerializationContext context, EffectOnCell semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     LineElement returns LineElement
	 *
	 * Constraint:
	 *     (Position=EInt? celltype=[CellType|EString]? cellstate=[CellState|EString]? brickstate=[BrickState|EString]? bricktype=[BrickType|EString]?)
	 * </pre>
	 */
	protected void sequence_LineElement(ISerializationContext context, LineElement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Line returns Line
	 *
	 * Constraint:
	 *     (Horizontal?='Horizontal' Vertical?='Vertical' Diagonal?='Diagonal' lineelement+=LineElement lineelement+=LineElement*)
	 * </pre>
	 */
	protected void sequence_Line(ISerializationContext context, Line semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Outcome returns Outcome
	 *
	 * Constraint:
	 *     (Name=EString condition+=[Condition|EString] condition+=[Condition|EString]*)
	 * </pre>
	 */
	protected void sequence_Outcome(ISerializationContext context, Outcome semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     PlayerBrickSet returns PlayerBrickSet
	 *
	 * Constraint:
	 *     (
	 *         Name=EString 
	 *         win+=[Outcome|EString] 
	 *         win+=[Outcome|EString]* 
	 *         draw=[Outcome|EString]? 
	 *         brick+=Brick 
	 *         brick+=Brick*
	 *     )
	 * </pre>
	 */
	protected void sequence_PlayerBrickSet(ISerializationContext context, PlayerBrickSet semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     RelativePosition returns RelativePosition
	 *
	 * Constraint:
	 *     (Xchange=EInt Ychange=EInt)
	 * </pre>
	 */
	protected void sequence_RelativePosition(ISerializationContext context, RelativePosition semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, BgPackage.Literals.RELATIVE_POSITION__XCHANGE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, BgPackage.Literals.RELATIVE_POSITION__XCHANGE));
			if (transientValues.isValueTransient(semanticObject, BgPackage.Literals.RELATIVE_POSITION__YCHANGE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, BgPackage.Literals.RELATIVE_POSITION__YCHANGE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getRelativePositionAccess().getXchangeEIntParserRuleCall_3_0(), semanticObject.getXchange());
		feeder.accept(grammarAccess.getRelativePositionAccess().getYchangeEIntParserRuleCall_5_0(), semanticObject.getYchange());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Rules returns Rules
	 *
	 * Constraint:
	 *     (board+=Board board+=Board*)
	 * </pre>
	 */
	protected void sequence_Rules(ISerializationContext context, Rules semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ValidMove returns ValidMove
	 *
	 * Constraint:
	 *     (
	 *         Name=EString 
	 *         (brickchange+=[BrickChange|EString] brickchange+=[BrickChange|EString]*)? 
	 *         (cellchange+=[CellChange|EString] cellchange+=[CellChange|EString]*)?
	 *     )
	 * </pre>
	 */
	protected void sequence_ValidMove(ISerializationContext context, ValidMove semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
}
