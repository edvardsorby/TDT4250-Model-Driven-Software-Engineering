/*
 * generated by Xtext 2.35.0
 */
package no.ntnu.tdt4250.g07.bg.bgdl.generator

import java.util.Collection
import no.ntnu.tdt4250.g07.bg.BoardGame
import no.ntnu.tdt4250.g07.bg.BoardGameElement
import no.ntnu.tdt4250.g07.bg.Direction
import no.ntnu.tdt4250.g07.bg.Line
import no.ntnu.tdt4250.g07.bg.PieceType
import no.ntnu.tdt4250.g07.bg.WinCondition
import org.eclipse.emf.ecore.EObject
import org.eclipse.emf.ecore.EStructuralFeature
import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.generator.AbstractGenerator
import org.eclipse.xtext.generator.IFileSystemAccess2
import org.eclipse.xtext.generator.IGeneratorContext

/**
 * Generates code from your model files on save.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */

class BoardGameDLGenerator extends AbstractGenerator {

    override void doGenerate(Resource resource, IFileSystemAccess2 fsa, IGeneratorContext context) {
        val boardGame = resource.allContents.filter(BoardGame).head
        if (boardGame !== null) {
            fsa.generateFile("config.js", generateConfigJS(boardGame)) 
            fsa.generateFile("winConditions.js", generateWinConditionsJS(boardGame))
            fsa.generateFile("boardGame.js", generateBoardGameJS(boardGame))
            fsa.generateFile("boardStyles.js", generateBoardStyleJS(boardGame))  
        }
    }

    def String generateConfigJS(BoardGame boardGame) {
        '''
const boardGame = {
	title: "«boardGame.name»",
    size: «boardGame.size»,
    «val pieceTypes = boardGame.boardGameElements.filter(PieceType)»
    pieces: [«FOR pieceType : pieceTypes»
    "«pieceType.symbol»",
    «ENDFOR»]
};
export default boardGame;
       '''
       
       /**
        *       config: {
           		«boardGame.boardGameElements.groupBy[eClass.name].entrySet.map[
                       decapitalize(key) + ': [' + value.map[generateElementJS(it)].join(",") + ']'
                   ].join(",\n")»
            }
        */
    }
    
    def String generateElementJS(BoardGameElement element) {
    '''{«element.eClass.EAllStructuralFeatures.map[serializeFeature(it, element)].join(",")»}'''
	}

	def String serializeFeature(EStructuralFeature feature, EObject element) {
	    val value = element.eGet(feature)
	    '''«feature.name»: «serializeValue(value)»'''
	}
	
	def String serializeValue(Object value) {
	    if (value instanceof String || value instanceof Enum) 
	        return '"' + value + '"'
	    else if (value instanceof Boolean)
	        return value.toString
	    else if (value instanceof Collection<?>)
	        return '[' + value.map[serializeValue(it)].join(", \n") + ']'
	    else if (value instanceof EObject)
	        return '{ ' + value.eClass.EAllStructuralFeatures.map[serializeFeature(it, value)].join(", ") + ' }'
	    else
	        return value.toString
	}
	
	
		def generateWinConditionsJS(BoardGame boardGame){
		val winConditions = boardGame.boardGameElements.filter(WinCondition)
		'''
			// Auto-generated JavaScript for win conditions
			const boardSize = «boardGame.size»;
			  
			export function checkIsFinishedFunction(board, players, currentPlayer, setMessage) {
				const newBoard = board;
				let isFinished = false;
			
				const player = players[currentPlayer]
			    «FOR winCondition : winConditions»
    				«FOR winConditionElement : winCondition.winConditionElements »
    			     	«IF winConditionElement instanceof Line»
    			     		«IF winConditionElement.direction == Direction.ROW»
    			   
    			const inARowLength = «winConditionElement.length»
				if(inARow(inARowLength, player, board)) {
					setMessage(`Player ${players[currentPlayer].symbol} wins because of ${inARowLength} in a row!`);
					return true
				}
    						«ELSEIF winConditionElement.direction == Direction.COLUMN»
    			const inAColumnLength = «winConditionElement.length»
	     		if(inAColumn(inAColumnLength, player, board)) {
	     			setMessage(`Player ${players[currentPlayer].symbol} wins because of ${inAColumnLength} in a column!`);
	     			return true
	     		}
    						«ELSEIF winConditionElement.direction == Direction.DIAGONAL»
    			const inADiagonalLength = «winConditionElement.length»
	     		if(inDiagonal(inADiagonalLength, player, board)) {
	     			setMessage(`Player ${players[currentPlayer].symbol} wins because of ${inADiagonalLength} in a diagonal!`);
	     			return true
	     		}
    			     		«ENDIF»
    			     	«ENDIF»
    			 	«ENDFOR»
			    «ENDFOR»	
			    	   
			  	return false; //not finished
			};
			
			      «FOR winCondition : winConditions»
			         				«FOR winConditionElement : winCondition.winConditionElements »
			         			     	«IF winConditionElement instanceof Line»
			         			     		«IF winConditionElement.direction == Direction.ROW»
			  const inARow = (num, player, board) => {
			    for (let row = 0; row < boardSize; row++) {
			      let count = 0;   
			      for (let col = 0; col < boardSize; col++) {
			        if (
			       		board[row][col] != null && 
			            board[row][col].piece != null && 
			            board[row][col].piece.symbol === player.symbol
			            ){
			          count++;
			          if (count === num) return true;
			        } else {
			          count = 0;
			        }
			      }
			    }
			    return false;
			  };
			  
			«ELSEIF winConditionElement.direction == Direction.COLUMN»
			  const inAColumn = (num, player, board) => {
			    for (let col = 0; col < boardSize; col++) {
			      let count = 0;
			      for (let row = 0; row < boardSize; row++) {
			        if(
			       		board[row][col] != null && 
			            board[row][col].piece != null && 
			            board[row][col].piece.symbol === player.symbol
			            ){
			          count++;
			          if (count === num) return true;
			        } else {
			          count = 0;
			        }
			      }
			    }
			    return false;
			  };
			  
			«ELSEIF winConditionElement.direction == Direction.DIAGONAL»
			  const inDiagonal = (num, player, board) => {
			    const countDiagonalMatches = (startRow, startCol, deltaRow, deltaCol) => {
			      let count = 0;
			      let row = startRow;
			      let col = startCol;
			
			      while (row >= 0 && row < boardSize && col >= 0 && col < boardSize) {
			        if(
			       		board[row][col] != null && 
			            board[row][col].piece != null && 
			            board[row][col].piece.symbol === player.symbol
			            ){
			          count++;
			          if (count === num) return true;
			        } else {
			          count = 0;
			        }
			        row += deltaRow;
			        col += deltaCol;
			      }
			      return false;
			    };
			    
			    			    // Check top-left to bottom-right
			    			    for (let row = 0; row < boardSize; row++) {
			    			      if (countDiagonalMatches(row, 0, 1, 1)) return true;
			    			    }
			    			    for (let col = 1; col < boardSize; col++) {
			    			      if (countDiagonalMatches(0, col, 1, 1)) return true;
			    			    }
			    			
			    			    // Check top-right to bottom-left
			    			    for (let row = 0; row < boardSize; row++) {
			    			      if (countDiagonalMatches(row, boardSize - 1, 1, -1)) return true;
			    			    }
			    			    for (let col = boardSize - 2; col >= 0; col--) {
			    			      if (countDiagonalMatches(0, col, 1, -1)) return true;
			    			    }
			    			
			    			    return false;
			    			  };
			    
			     		«ENDIF»
			       «ENDIF»
			 	«ENDFOR»
		    «ENDFOR»
			'''
			}
	
	def generateBoardGameJS(BoardGame boardGame) {
		'''
			import { View, TouchableOpacity, Text } from "react-native";
			import { useState, useEffect } from "react";
			import CustomButton from "../components/button.js";
			import { boardStyles } from "./boardStyles.js";
			import React from 'react'
			import { checkIsFinishedFunction } from "./winConditions.js";
			
			export default function BoardGame() {
			  const boardSize = «boardGame.size»; // Size of the board
			  «val pieceTypes = boardGame.boardGameElements.filter(PieceType)»
			  let players = [«FOR pieceType : pieceTypes»
		      {symbol:"«pieceType.symbol»",
		      disallowedStates: [«FOR state : pieceType.disallowedStates»"«state.name»",«ENDFOR»],
		      effectsOnCell: [«FOR effect : pieceType.effectsoncell»{state: "«effect.cellState.name»", x:«effect.x», y:«effect.y»},«ENDFOR»]},«ENDFOR»]
	
			  const [board, setBoard] = useState(Array(boardSize).fill(Array(boardSize).fill(null)));
			  const [currentPlayer, setCurrentPlayer] = useState(0);
			  const [gameActive, setGameActive] = useState(true);
			
			  // start message
			  const [message, setMessage] = useState(``);
			
			  //Board
			  const predefinedBoard = Array(boardSize).fill(Array(boardSize).fill(null));
			 
			  
			  const initializeBoard = () => {
			    //const newBoard = predefinedBoard.map(row => row.slice()); 
			    setBoard(predefinedBoard);
			
			    setCurrentPlayer(0); 
			    setMessage(`Next Piece ${players[0].symbol}`);
			
			    setGameActive(true);
			  };
			
			  useEffect(() => {   
			    initializeBoard()
			  }, []);
			  
			    const checkIfMoveIsAllowed = (disallowedStates, row, col) => {
			      const cell = board[row][col]
			  
			      if (cell === null) {
			        return true
			      } else {
			        const cellStates = cell.states
			  
			        for (let i = 0; i < cellStates.length; i++) {
			          const state = cellStates[i];
			  
			          for (let j = 0; j < disallowedStates.length; j++) {
			            const disallowedState = disallowedStates[j];
			            if (state === disallowedState) return false
			          }
			          
			        }
			        return true
			      }
			    }
			    
			    const updateBoard = (piece, row, col) => {
			    
			        
			        const effectsOnCell = piece.effectsOnCell
			        
			        let newBoard = board.map(row => [...row]);
			        
			        for (let i = 0; i < effectsOnCell.length; i++) {

			          const effect = effectsOnCell[i];
			          
			          const affectedRow = row + effect.y
			          const affectedCol = col + effect.x
			    
			          if (
			            !((affectedRow >= boardSize || affectedRow < 0)
			            ||(affectedCol >= boardSize || affectedCol < 0))
			          ) {
			            let newCell
			            
			            if (board[affectedRow][affectedCol] === null) {
			              newCell = {}
			              
			          
			              newCell.states = [effect.state]
			            } else {
			              newCell = board[affectedRow][affectedCol]
			              
			              newCell.states.push(effect.state)
			      
			            }
			            
				        if (affectedRow === row && affectedCol === col) {
					        newCell.piece = piece
					    }
			            
			            newBoard[affectedRow][affectedCol] = newCell
			          }
			          
			        }
		         setBoard(newBoard)
		            return newBoard
		         }
			        
			
			   const onCellClick = (row, col) => {
			  
			      const currentPlayerPiece = players[currentPlayer]
			  
			      let newBoard
			  
			      if (checkIfMoveIsAllowed(currentPlayerPiece.disallowedStates, row, col) && gameActive) {
			        newBoard = updateBoard(currentPlayerPiece, row, col)
			      } else {
			        setMessage("Disallowed move")
			        return
			      }
			  
			      if (checkIsFinished(newBoard)) {
			        setGameActive(false);
			      } else if (checkIfBoardIsFilled(newBoard)) {
			        setMessage("It's a draw!");
			        setGameActive(false);
			      } else {
			        const nextPlayer = (currentPlayer + 1) % players.length;
			        setCurrentPlayer(nextPlayer);
			        setMessage(`Next piece: ${players[nextPlayer].symbol}`);
			      }
			    };
			
			  const checkIsFinished = (board) => {
			    return checkIsFinishedFunction(board, players, currentPlayer, setMessage)
			  }
			
			  const checkIfBoardIsFilled = (board) => {
			    return board.flat().every((cell) => cell !== null);
			  };
			
			  const resetGame = () => {
			    initializeBoard();
			  };
			  return (
			    
			<View style={boardStyles.container}>
			     <Text style={boardStyles.title}>«boardGame.name»</Text>
			     <Text style={boardStyles.message}>
			             Players: {players.map((player, index) => (
			               <Text
			                 key={index}
			                 style={player === players[currentPlayer] ? { fontSize: 32 } : null}
			               >
			                 {player.symbol}{' '}
			               </Text>
			             ))}
	           	  </Text>
			      <Text style={boardStyles.message}>{message}</Text>
			      <View style={boardStyles.board}>
			        {board.map((row, rowIndex) =>
			          row.map((cell, colIndex) => (
			            <TouchableOpacity
			              key={`${rowIndex}-${colIndex}`}
			              style={boardStyles.cell}
			              onPress={() => onCellClick(rowIndex, colIndex)}
			            >
			              <Text style={boardStyles.cellText}>{cell != null && cell.piece != null && cell.piece.symbol}</Text>
			            </TouchableOpacity>
			          ))
			        )}
			      </View>
			     <View style={boardStyles.rules}>
		             <Text style={boardStyles.rule}>Rules:</Text>
	             
			      «val winConditions = boardGame.boardGameElements.filter(WinCondition)»
			        «FOR winCondition : winConditions»
         				«FOR winConditionElement : winCondition.winConditionElements »
         			     	«IF winConditionElement instanceof Line»
         			     		 		<Text style={boardStyles.rule}>«winConditionElement.length»  in a «winConditionElement.direction.toString.toLowerCase»</Text>
         			     	«ENDIF»
        			 	«ENDFOR»
			    «ENDFOR»
			    </View>	
			      <CustomButton title="Reset" onPress={resetGame} />
			      
			    </View>
			  )
			}
		'''
	}
	
	def generateBoardStyleJS(BoardGame boardGame) {
		'''
			import { StyleSheet } from "react-native";
			import { RFValue } from "react-native-responsive-fontsize";
			
			export const boardStyles = StyleSheet.create({
			  container: {
			    flex: 1,
			    justifyContent: "center",
			    alignItems: "center",
			    backgroundColor: "azure",
			  },
			  title: {
			    fontSize: 36,
			    marginBottom: 10,
			    color: "#023535",
			  },
			  board: {
			    flexDirection: "row",
			    flexWrap: "wrap",
			    width: 300,
			    height: 300,
			    marginBottom: 20
			  },
			  cell: {
			    width:  300 / «boardGame.size»,
			    height:  300 / «boardGame.size»,
			    borderWidth: 2,
			    borderColor: "black",
			    justifyContent: "center",
			    alignItems: "center",
			    backgroundColor: "#fff",
			  },
			  cellText: {
			    fontSize: 35 - «boardGame.size»,
			    fontWeight: "bold",
			  },
			  message: {
			    fontSize: 24,
			    marginVertical: 5,
			    color: "#023535",
			  },
			  rules: {
			    padding: 5,
			    paddingHorizontal: 20,
			    marginBottom: 10,
			    backgroundColor: "#ffff99",
			    borderRadius: 5,
			  },
			  rule: {
			    margin: 0,
			    fontSize: 16,
			  }
			});
			
		'''
	}
	
		
	def decapitalize(String input) {
    	if (input.isEmpty) input
    	else input.substring(0, 1).toLowerCase + input.substring(1)
	}
}

