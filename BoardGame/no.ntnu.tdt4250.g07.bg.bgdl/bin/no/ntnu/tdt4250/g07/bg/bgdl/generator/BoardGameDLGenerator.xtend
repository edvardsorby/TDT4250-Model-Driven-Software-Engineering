/*
 * generated by Xtext 2.35.0
 */
package no.ntnu.tdt4250.g07.bg.bgdl.generator

import no.ntnu.tdt4250.g07.BoardGame.CellState
import no.ntnu.tdt4250.g07.bg.BoardGame
import no.ntnu.tdt4250.g07.bg.Condition
import no.ntnu.tdt4250.g07.bg.PieceType
import no.ntnu.tdt4250.g07.bg.ValidMove
import no.ntnu.tdt4250.g07.bg.WinCondition
import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.generator.AbstractGenerator
import org.eclipse.xtext.generator.IFileSystemAccess2
import org.eclipse.xtext.generator.IGeneratorContext

/**
 * Generates code from your model files on save.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */

class BoardGameDLGenerator extends AbstractGenerator {

    override void doGenerate(Resource resource, IFileSystemAccess2 fsa, IGeneratorContext context) {
        val boardGame = resource.allContents.filter(BoardGame).head
        if (boardGame !== null) {
            fsa.generateFile("boardGame.js", generateJS(boardGame))
        }
    }

    def String generateJS(BoardGame boardGame) {
        '''
        const boardGame = {
            size: «boardGame.size»,
            piecetypes: [
                «boardGame.piecetypes.map[generatePieceType(it)].join(",\n")»
            ],
            cellstates: [
                «boardGame.cellstates.map[CellState.name].join(", ")»
            ],
            winConditions: [
                «boardGame.winConditions.map[generateWinCondition(it)].join(",\n")»
            ]
        };

        export default boardGame;
        '''
    }

    def String generatePieceType(PieceType pieceType) {
        '''
        {
            name: "«pieceType.name»",
            symbol: "«pieceType.symbol»",
            validmoves: [
                «pieceType.validmoves.map[generateValidMove(it)].join(",\n")»
            ]
        }
        '''
    }

    def String generateValidMove(ValidMove validMove) {
        '''
        {
            placeAnywhere: «validMove.placeAnywhere»,
            conditions: [
                «validMove.conditions.map[generateCondition(it)].join(",\n")»
            ]
        }
        '''
    }

    def String generateCondition(Condition condition) {
        '''
        {
            cellstate: "«condition.cellstate.name»"
        }
        '''
    }

    def String generateWinCondition(WinCondition winCondition) {
        '''
        {
            inarow: {
                diagonal: «winCondition.inarow.diagonal»,
                horizontal: «winCondition.inarow.horizontal»,
                vertical: «winCondition.inarow.vertical»,
                count: «winCondition.inarow.count»
            }
        }
        '''
    }
}

